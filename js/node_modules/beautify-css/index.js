#!/usr/bin/env node
var css = require('css'),
    rw = require('rw'),
    yargs = require('yargs')
      .usage('$0 [options] [input] [output]')
      .describe('indent', 'indent with this number of spaces (or string)')
      .describe('encoding', 'string encoding (default: "utf8")')
      .describe('compress', 'compress output, removing whitespace and comments')
        .boolean('compress')
      .describe('source-map', 'generate a source map, and write it to this file')
      .describe('source-in', 'reference one or more input source maps')
      .describe('in-place', 'modify the input file in place')
        .boolean('in-place')
      .describe('v', 'output helpful messages to stderr')
        .boolean('v')
      .alias('indent', 'i')
      .alias('compress', 'c')
      .alias('encoding', 'e')
      .alias('in-place', 'p')
      .alias('h', 'help'),
    options = yargs.argv,
    argc = options._,
    input = '/dev/stdin',
    output = '/dev/stdout',
    fileOptions = {
      encoding: options.encoding
    };

if (options.help) {
  yargs.showHelp();
  return process.exit(1);
}

if (argc.length) {
  input = dash(argc.shift(), '/dev/stdin');
  if (options['in-place']) {
    output = input;
  } else if (argc.length) {
    output = argc.shift();
  }
}

if (options['in-place']
    && (input === '/dev/stdin' || output === '/dev/stdout')) {
  ERROR('Error: --in-place/-p is incompatible with stdio\n');
  yargs.showHelp();
  return process.exit(1);
}

var inputOptions = {
      silent: false,
      source: (input === '/dev/stdin')
        ? null
        : input
    },
    outputOptions = {
      indent:     (typeof options.indent === 'number')
        ? repeat(' ', options.indent)
        : options.indent,
      compress:   options.c,
      sourcemap:  options['source-map'],
      inputSourcemaps: options['source-in']
    };

LOG('beautifying: %s -> %s', input, output);

rw.readFile(input, options, function(error, buffer) {
  if (error) return ERROR('read error:', error);

  var start = Date.now(),
      ast = css.parse(buffer.toString(), inputOptions),
      parseTime = Date.now() - start,
      out = css.stringify(ast, outputOptions) + '\n',
      formatTime = Date.now() - start - parseTime;

  LOG('took %ss to parse, %ss to format',
    (parseTime / 1000).toFixed(2),
    (formatTime / 1000).toFixed(2));

  rw.writeFile(output, out, options, function(error) {
    if (error) return ERROR('write error:', error);
  });
});

function LOG() {
  if (!options.v) return;
  console.warn.apply(console, arguments);
}

function ERROR() {
  console.error.apply(console, arguments);
}

function dash(name, stdio) {
  return name === '-' ? stdio : name;
}

function repeat(str, times) {
  var out = [];
  for (var i = 0; i < times; i++) out.push(str);
  return out.join('');
}
